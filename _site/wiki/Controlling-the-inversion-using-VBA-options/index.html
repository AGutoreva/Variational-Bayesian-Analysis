<!DOCTYPE html>
<html>

      <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>VBA toolbox</title>
        <meta name="viewport" content="width=device-width">
        <meta name="description" content="Write an awesome description for your new site here. It will appear in your document head meta (for Google search results) and in your feed.xml site description." />
        <link rel="canonical" href="/wiki/Controlling-the-inversion-using-VBA-options//" />

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">
        <!-- <link rel="stylesheet" href="/css/pygments_default.css">-->

<!-- icon font -->
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!--<script type="text/javascript" src="/js/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript" src="/js/jQuery.js"></script>
<script type="text/javascript" src="/js/toc.js"></script>-->
<script type="text/javascript">
$(document).ready(function() {
    $('.toc').toc();
});
</script>

<!--<script type="text/javascript" src="/js/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->

    </head>


    <body>

    <header class="site-header">

  <div class="wrap">

    <a class="site-title" href="/">VBA toolbox</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
           viewBox="0 0 18 15" enable-background="new 0 0 18 15" xml:space="preserve">
          <path fill="#505050" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0
            h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#505050" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484
            h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#505050" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0
            c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <div class="trigger">
        <a class="page-link" href="/install"><i class="fa fa-download"></i> Install</a>
        <a class="page-link" href="/wiki"><i class="fa fa-book"></i> Wiki</a>
        <a class="page-link" href="/about"><i class="fa fa-mortar-board"></i> About</a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrap">
      <div class="post">
  <header class="post-header">
  <h1 id="title"><a href="/wiki">WIKI</a>&nbsp;Controlling the inversion using VBA options</h1>
 </header>

  <article class="post-content">
    <hr/>
  <ul id="markdown-toc">
  <li><a href="#dealing-with-categorical-or-missing-data">Dealing with categorical or missing data</a></li>
  <li><a href="#micro-time-resolution">“Micro-time” resolution</a></li>
  <li><a href="#optional-arguments-to-evolutionobservation-functions">Optional arguments to evolution/observation functions</a></li>
  <li><a href="#controlling-the-lagged-kalman-forward-pass">Controlling the lagged Kalman forward pass</a></li>
  <li><a href="#controlling-the-vba-algorithmic-convergence">Controlling the VBA algorithmic convergence</a></li>
  <li><a href="#vba-initialization-for-stochastic-dynamical-systems">VBA initialization for stochastic dynamical systems</a></li>
  <li><a href="#switching-onoff-graphical-display">Switching on/off graphical display</a></li>
  <li><a href="#volterra-kernels">Volterra kernels</a></li>
  <li><a href="#miscellaneous">Miscellaneous</a>    <ul>
      <li><a href="#by-passing-the-evolution-function-at-times">By-passing the evolution function at times</a></li>
      <li><a href="#switching-off-some-vb-updates">Switching off some VB updates</a></li>
      <li><a href="#checking-analytical-gradients-against-numerical-gradients">Checking analytical gradients against numerical gradients</a></li>
      <li><a href="#dealing-with-delayed-dynamical-systems">Dealing with delayed dynamical systems</a></li>
    </ul>
  </li>
</ul>

<p>Strictly speaking, the main VBA inversion routine (<code>VBA_NLStateSpaceModel.m</code>) only requires the specification of evolution/observation functions and the model dimension (see <a href="/wiki/VBA-model-inversion-in-4-steps">this page</a> for a quick introduction).<br />
However, optional arguments can be passed to this function, that allow the user to control the inversion. These are reviewed here.</p>

<h1 id="dealing-with-categorical-or-missing-data">Dealing with categorical or missing data</h1>

<p>By default, VBA’s generative model assumes observed data are continuous, for which there is a natural distance metric. Now if the data is categorical, there is no such natural metric, and one has to resort to probability distributions dealing with discrete events. For example, binary data can be treated as binomial (Bernouilli) samples, whose sufficient statistic (first-order moment) is given by the observation function. This can be done by setting:</p>

<pre><code>options.binomial = 1;
</code></pre>

<p>Note that this renders the measurement noise precision (and associated covariance components, see below) irrelevant. It turns out that this does not induce any major change in the VB inversion scheme under the Laplace approximation. In fact, when the dimension of the data is high enough, the empirical distribution of the ‘residuals’ will tend to a Gaussian density (this is actually used during VBA’s initialization).</p>

<p>In addition, one may want to simply exclude data samples (either because one knows that they are unreliable, or because one has missing data). This can be done using the variable <code>options.isYout</code>. By default, <code>options.isYout</code> is a zero-valued matrix, whose size is identical to the data matrix <code>y</code>. Setting any of its value to one effectively asks VBA to disregard the corresponding data sample. For example:</p>

<pre><code>options.isYout(1:2,3) = 1;
</code></pre>
<p>means that the third time sample of the two first dimensions of <code>y</code> will not be considered in the inversion.</p>

<blockquote>
  <p><strong>TIP:</strong> when dealing with continuous data, the same can be obtained by setting the corresponding measurement precision component to zero!</p>
</blockquote>

<h1 id="micro-time-resolution">“Micro-time” resolution</h1>

<p>The evolution equation is discrete in time. If one directly uses this as an approximation to a continuous dynamical system, then the approximation’s accuracy strongly depends on the data sampling frequency. However, the toolbox allows one to specify a microtime resolution, which is used to recursively apply the evolution function between two time samples. This can be useful to control the time discretization errors introduced when approximating the original continuous dynamical system.</p>

<p>For example: how can one use a discrete time step of 100ms for the evolution function, given that the sampling rate is 1sec?<br />
Setting:</p>

<pre><code>options.decim = 10;
</code></pre>
<p>effectively asks VBA to recursively evaluate the evolution function ten times between two time samples. This resolves the problem if one passes a discrete time step of 100msec to the evolution function (see below).</p>

<p>One may also want to define the controlled input <code>u</code> time series at the micro-time resolution. This is done by setting:</p>

<pre><code class="language-matlab">options.microU = 1;
</code></pre>
<p>If this is not the case, then VBA replicates the sampled input for each micro-time call of the evolution function.</p>

<h1 id="optional-arguments-to-evolutionobservation-functions">Optional arguments to evolution/observation functions</h1>

<p>One may have to pass some arbitrary information to the evolution/observation functions. For example, when dealing with continuous dynamical systems, one may want to control the time discretization step (see above). This can be done by setting:</p>

<pre><code class="language-matlab">options.inF.dt = 0.1;
</code></pre>
<p>where <code>inF.dt</code> is read out in the evolution function (and used accordingly; here: units would be seconds).</p>

<blockquote>
  <p><strong>TIP:</strong> Optional arguments to the observation function are passed through <code>options.inG</code>.</p>
</blockquote>

<p>Note that the contents of the fields<code>options.inF</code> and <code>options.inG</code> are entirely arbitrary, since they are interpreted by the evolution/observation functions…</p>

<h1 id="controlling-the-lagged-kalman-forward-pass">Controlling the lagged Kalman forward pass</h1>

<p>The VBA update of the hidden states is very similar in form to a Kalman filter. More precisely, the scheme derives an approximation to the lagged posterior density, which contains the information about states at time <code>t</code> given all observed data up to time <code>t+k</code>, where <code>k</code> is the lag. This lag can be chosen arbitrarily, which allows one to infer on hidden states, whose changes impact observed data a few time samples later in time (e.g. due to some form of convolution operation). For example, the following sets the lag to 10:</p>

<pre><code class="language-matlab">options.backwardLag = 10;
</code></pre>

<p>The main effect of increasing the lag is to average across more data points when deriving the hidden states, hence improving the precision (and the temporal smoothness) of the estimate.</p>

<blockquote>
  <p><strong>TIP:</strong> The ensuing computational cost scales with <code>k^2</code>.</p>
</blockquote>

<h1 id="controlling-the-vba-algorithmic-convergence">Controlling the VBA algorithmic convergence</h1>

<p>The free energy eventually serves as an analytical approximation to the log model evidence, but it is also used to monitor the algorithmic convergence of the algorithm. More precisely, VBA stops whenever the maximum number of iterations has been reached, or the increase in free energy has fallen below a predefined threshold. These two criteria can be controlled, e.g.:</p>

<pre><code class="language-matlab">options.MaxIter = 10;
options.TolFun = 1e-4;
</code></pre>

<p>Note that a minimum number of iterations can be fixed using <code>options.MinIter</code>.</p>

<p>In addition, VB updates of the posterior mean of hidden states and evolution/observation parameters rely upon an inner loop of iterative Gauss-Newton schemes. Here again, the number of iterations as well as the relevant variational energy are monitored. They can be controlled by setting:</p>

<pre><code class="language-matlab">options.GnMaxIter = 10;
options.GnTolFun = 1e-4;
</code></pre>

<blockquote>
  <p><strong>TIP:</strong> instead of monitoring the variational energy through Gauss-Newton inner loops, one may want to force positive steps in the free energy itself. This can be done by setting:</p>

  <pre><code class="language-matlab">options.gradF = 1;
</code></pre>
</blockquote>

<h1 id="vba-initialization-for-stochastic-dynamical-systems">VBA initialization for stochastic dynamical systems</h1>

<p>When dealing with stochastic dynamical systems, VBA initializes the inversion under a deterministic variant of the model. This automatically done by simply another call to VBA, having set the prior mean of the states noise variance to zero (with infinite prior precision, see below). However, one may want to control the convergence of the VBA initialization. For example, setting:</p>

<pre><code class="language-matlab">options.MaxIterInit = 0;
</code></pre>
<p>effectively bypasses the VBA initialization.</p>

<p>In addition to initialized posterior densities on evolution/observation parameters and initial conditions, the VBA initialization also derives the posterior on measurement noise precision. However, the deterministic variant might be lead to such strong model residuals, that one may want to ignore this. This can be done by setting:</p>

<pre><code class="language-matlab">options.initHP = 0;
</code></pre>
<p>Here, the prior on measurement noise precision will be used instead of its posterior (under the deterministic variant model), when initializing the posterior for the stochastic inversion.</p>

<h1 id="switching-onoff-graphical-display">Switching on/off graphical display</h1>

<p>By default, VBA outputs a graphical summary of inversion results as the algorithm proceeds. However, this slows down the inversion. Setting:</p>

<pre><code class="language-matlab">options.DisplayWin = 0;
</code></pre>
<p>effectively switches off the graphical display (NB: one can reproduce the graphical output post-hoc, by calling:</p>

<pre><code class="language-matlab">VBA_ReDisplay(posterior,out);
</code></pre>
<p>where <code>posterior</code> and <code>out</code> are the two output arguments of the VBA inversion.</p>

<p>Having said this, one may want to eyeball inner Gauss-Newton iterations, for diagnosis purposes. This can be done by setting:</p>

<pre><code class="language-matlab">options.GnFigs = 1;
</code></pre>

<blockquote>
  <p><strong>TIP:</strong> additional information is give in the main matlab window (e.g., default priors fill-in, free energy increases, etc…). This can also be switched off by setting:</p>

  <pre><code class="language-matlab">options.verbose = 0;
</code></pre>
</blockquote>

<h1 id="volterra-kernels">Volterra kernels</h1>

<p>When dealing with dynamical systems, VBA eventually performs a Volterra decomposition of hidden states dynamics onto the set <code>u</code> of inputs to the system. This diagnostic analysis allows one to identify the hidden states’ impulse response to experimentally controlled inputs to the system. Setting:</p>

<pre><code class="language-matlab">options.kernelSize = 32;
</code></pre>
<p>effectively asks VBA to estimate Volterra kernels with a maximum lag of 32 time samples.</p>

<p>In addition, one may want to orthogonalize the inputs prior to the Volterra decomposition. This can be done by setting:</p>

<pre><code class="language-matlab">options.orthU = 1;
</code></pre>
<p>The inputs are orthogonalized in order, i.e. the second input is orthogonalized w.r.t. the first, the third is orthogonalized w.r.t. the first and the second, etc…</p>

<p>One may also want to detrend inputs. The variable <code>options.detrendU</code> controls the order of a polynomial Taylor series which is removed from the inputs and from the system’s dynamics. For example:</p>

<pre><code class="language-matlab">options.detrendU = 3;
</code></pre>
<p>will explain away any temporal variability (in the inputs and system’s dynamics), which can be explained by a cubic function of time.</p>

<p>Note that one may want to Volterra-decompose the system’s dynamics onto another set of inputs. This can be done as follows:</p>

<pre><code class="language-matlab">out.u = u0;
out = rmfield(out,'diagnostics');
[hf,out0] = VBA_ReDisplay(out,posterior,1);
</code></pre>
<p>This first re-sets the inputs in the <code>out</code> structure with the appropriate set (here, <code>u0</code>). Then, the <code>diagnostics</code> structure is removed from <code>out</code>. Therefore, when called, <code>VBA_ReDisplay</code> derives the Volterra deomcposition w.r.t. <code>u0</code>, instead of <code>u</code>. These will be stored in <code>out0.diagnostics.kernels</code> (but can be eyeballed directly from the graphical results window).</p>

<h1 id="miscellaneous">Miscellaneous</h1>

<h2 id="by-passing-the-evolution-function-at-times">By-passing the evolution function at times</h2>

<p>One may want to skip the evolution function at times, i.e. replace it with the identity mapping. For example, this is useful when dealing with learning models, where the transition from the initial conditions to the first states is ill-defined (because no feedback has yet been received). This can be done by setting the variable <code>options.skipf</code>. By default, <code>options.skipf</code> is a zero-valued matrix, whose length is the number of time samples. Setting any of its value to one effectively asks VBA to replace the corresponding states transition by the identity mapping. For example:</p>

<pre><code class="language-matlab">options.skipf(1) = 1;
</code></pre>
<p>means that the first hidden states are copies of the initial conditions.</p>

<h2 id="switching-off-some-vb-updates">Switching off some VB updates</h2>

<p>One may want to bypass the VB updates of states’ initial conditions and/or precision hyperparameters. This can be done by setting:</p>

<pre><code class="language-matlab">options.updateX0 = 0;
</code></pre>
<p>and:</p>

<pre><code class="language-matlab">options.updateHP = 0;
</code></pre>
<p>respectively.</p>

<blockquote>
  <p><strong>TIP:</strong> this is not identical to setting the variance of their respective priors to 0, because the free energy derivation still depends upon the prior and posterior uncertainty affecting these variables.</p>
</blockquote>

<h2 id="checking-analytical-gradients-against-numerical-gradients">Checking analytical gradients against numerical gradients</h2>

<p>One may want to augment the evolution/observation functions with analytical gradients (w.r.t. states and parameters). This is useful to accelerate the inversion, because it bypasses the default numerical derivations. Because this may be tedious (and thus prone to errors), VBA allows model developpers to eyeball a comparison of their analytical gradients with numerical gradients. This is done by setting:</p>

<pre><code class="language-matlab">options.checkGrads= 1;
</code></pre>

<h2 id="dealing-with-delayed-dynamical-systems">Dealing with delayed dynamical systems</h2>

<p>VBA can deal with certain forms of delays by embedding the state space   into an augmented state-space, which contains copies of states and their ‘previous’ values. The evolution function is then automatically wrapped, so that it receives delayed states. Such delays can be controlled using the variable <code>options.delays</code>. We refer the interested reader to the demonstration script <code>demo_delays.m</code>.</p>

 <hr/>
  <div class='return_link'><a href="#title"><i class="fa fa-chevron-up"></i> back to top</a></div>
  </article>


</div>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrap">


    <div class="footer-col-1 column">
        <h2 class="footer-heading">Participate to the VBA-toolbox!</h2>

          <ul>
        <li>
           <i class="fa fa-github-square fa-fw "></i>
          <a href="https://github.com/MBB-team/VBA-toolbox/fork">fork on Github</a>
        </li>
        <li>
          <i class="fa fa-edit fa-fw "></i>
          <a href="https://github.com/MBB-team/VBA-toolbox/issues">post a request</a>
        </li>
        </ul>

    </div>

    <div class="footer-col-2 column">
     <ul>
        <li>Jean DAUNIZEAU</li>
        <li><a href="mailto:jean.daunizeau@gmail.com">jean.daunizeau[at]gmail.com</a></li>
      </ul>
      <ul>
        <li>Lionel RIGOUX</li>
        <li><a href="mailto:lionel.rigoux@gmail.com">lionel.rigoux[at]gmail.com</a></li>
      </ul>

     </div>

    <div class="footer-col-3 column">
<p>J. Daunizeau, V. Adam, L. Rigoux (2014), VBA: a probabilistic treatment of nonlinear models for neurobiological and behavioural data. PLoS Comp Biol 10(1): e1003441.</p>
    </div>

  </div>

</footer>


    </body>

</html>
